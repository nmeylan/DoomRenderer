// Generated by CoffeeScript 1.8.0
(function() {
  var ctx;

  window.applicationContext = {
    consoleText: null,
    consoleHolder: null,
    canvas: null,
    screenWidth: window.innerWidth,
    screenHeight: window.innerHeight,
    gl: null,
    crashed: false,
    gameVisible: true
  };

  ctx = window.applicationContext;

  requirejs.config({
    baseUrl: 'js/src',
    paths: {
      dom: 'dom',
      util: 'util',
      wad: 'wad'
    }
  });

  require(['dom/element', 'util/console', 'util/string', 'wad/wadbytedata', 'wad/wad', 'wad/wadloader'], function(element) {
    var crash, initializeShaders, initializeWebGl, startup;
    startup = function() {
      ctx.consoleText = document.querySelector('#consoleText');
      ctx.consoleHolder = document.querySelector('#consoleHolder');
      ctx.printToConsole('startup');
      ctx.canvas = document.querySelector("#game");
      ctx.canvas.setAttribute("width", "" + ctx.screenWidth + "px");
      ctx.canvas.setAttribute("height", "" + ctx.screenHeight + "px");
      ctx.printToConsole('set up canvas');
      initializeWebGl(ctx.canvas);
      ctx.printToConsole('WebGL context has been initialized');
      initializeShaders;
      ctx.printToConsole('Loading WAD');
      return ctx.loadFile();
    };
    initializeWebGl = function(canvas) {
      var gl;
      gl = canvas.getContext("webgl");
      if (!gl) {
        crash('Webgl context has not been initialized', null);
      }
    };
    initializeShaders = function() {
      var fragmentShader, shaderProgram, vertexPositionAttribute, vertexShader;
      fragmentShader = getShader(ctx.gl, "shader-fs");
      vertexShader = getShader(ctx.gl, "shader-vs");
      shaderProgram = ctx.gl.createProgram();
      ctx.gl.attachShader(shaderProgram, vertexShader);
      ctx.gl.attachShader(shaderProgram, fragmentShader);
      ctx.gl.linkProgram(shaderProgram);
      if (!ctx.gl.getProgramParameter(shaderProgram, ctx.gl.LINK_STATUS)) {
        crash("Unable to initialize the shader program.");
      }
      ctx.gl.useProgram(shaderProgram);
      vertexPositionAttribute = ctx.gl.getAttribLocation(shaderProgram, "aVertexPosition");
      return ctx.gl.enableVertexAttribArray(vertexPositionAttribute);
    };
    crash = function(title, payload, stackTrace) {
      var e;
      if (stackTrace == null) {
        stackTrace = null;
      }
      if (ctx.crashed) {
        throw payload;
      }
      try {
        ctx.canvas.setAttribute("style", "display:none;");
        ctx.gameVisible = false;
        document.exitPointerLock();
        document.querySelector("#consoleHolder").setAttribute("style", "");
      } catch (_error) {
        e = _error;
      }
      ctx.crashed = true;
      ctx.printToConsole("");
      ctx.printToConsole("");
      ctx.printToConsole("-------------------------------------------------");
      ctx.printToConsole("                      CRASH                      ");
      ctx.printToConsole("-------------------------------------------------");
      ctx.printToConsole(title);
      ctx.printToConsole("");
      ctx.printToConsole("" + payload);
      if (stackTrace !== null) {
        printToConsole("");
        printToConsole("Stack trace:");
        return printToConsole("" + stackTrace);
      }
    };
    return startup();
  });

}).call(this);

//# sourceMappingURL=main.js.map
